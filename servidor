#!/usr/bin/env python3
import asyncio
from tcp import Servidor
import re
from platform import system
import gc


def log(msg, *args, **kwargs):
    print('[LOG]::', msg, *args, **kwargs)


MSG_TERMINATOR = b'\n' if system() == 'Darwin' else b'\r\n'

CONNS_TABLE = {} # holds dangling messages :: { 'id_conn': 'mes..sage' }
USERS_TABLE = {} # { 'apelido': 'id_conn' }
CHANNEL_TABLE = {} # { 'canal': ['apelido0', 'apelido1', ...]}

def get_nick_from_conn(conn):
    for k, v in USERS_TABLE.items():
        if v == id(conn):
            return k


def get_object_by_id(id_):
    for obj in gc.get_objects():
        if id(obj) == id_:
            return obj


def validar_nome(nome):
    return re.match(br'^[a-zA-Z][a-zA-Z0-9_-]*$', nome) is not None


def msg(txt):
    return bytes(txt, 'utf-8') + MSG_TERMINATOR


def sair(conexao):
    print(conexao, 'conexão fechada')

    for k, v in USERS_TABLE.items():
        if v == id(conexao):
            del USERS_TABLE[k]


    curr_usr = get_nick_from_conn(conexao)
    for chnl_name, usr_lst in CHANNEL_TABLE.items():
        if curr_usr in usr_lst:
            for usr in usr_lst:
                get_object_by_id(USERS_TABLE[usr]).enviar(msg(f':{curr_usr.decode("utf-8")} QUIT :Connection closed'))
            CHANNEL_TABLE[chnl_name].pop()

    conexao.fechar()


def get_full_msg(conexao, dados):
    # Garante que a msgm esta completa
    if id(conexao) not in CONNS_TABLE:
        log(id(conexao), 'created in table')
        CONNS_TABLE[id(conexao)] = b''

    if not dados.endswith(MSG_TERMINATOR):
        CONNS_TABLE[id(conexao)] += dados
        return

    dados = CONNS_TABLE[id(conexao)] + dados
    del CONNS_TABLE[id(conexao)]
    log(id(conexao), 'deleted in table')

    return (conexao, dados[:-len(MSG_TERMINATOR)])


def dados_recebidos(conexao, dados):

    conexao, dados = get_full_msg(conexao, dados)

    try:
        cmd, payload = dados.split(b' ', 1)
    except:
        cmd, payload = dados.split(b' ', 1)[0], None

    cmd = cmd.upper()


    if dados == b'':
        return sair(conexao)


    if cmd == b'PING':
        conexao.enviar(b':server PONG server:' + payload)


    if cmd == b'NICK':
        payload = bytes(payload.decode("utf-8").lower(), 'utf-8')
        if not validar_nome(payload):
            # checa se nome esta ok
            return conexao.enviar(msg(f'server 432 apelido_atual {payload.decode("utf-8")} :Erroneous nickname'))

        if payload.decode("utf-8") in USERS_TABLE:
            # checa se usuario ja existe
            return conexao.enviar(msg(f':server 433 apelido_atual {payload.decode("utf-8")} :Nickname is already in use'))

        if id(conexao) in USERS_TABLE.values():
            # troca de usuario
            old_nick = get_nick_from_conn(conexao)

            conexao.enviar(msg(f':{old_nick} NICK {payload.decode("utf-8")}'))
            del USERS_TABLE[get_nick_from_conn(conexao)]
            USERS_TABLE[payload.decode("utf-8")] = id(conexao)

            for k, v in CHANNEL_TABLE.items():
                if old_nick in v:
                    CHANNEL_TABLE[k] = v.replace(old_nick, payload.decode("utf-8"))

            return

        conexao.enviar(msg(f':server 001 {payload.decode("utf-8")} :Welcome'))
        conexao.enviar(msg(f':server 422 {payload.decode("utf-8")} :MOTD File is missing'))

        # adiciona usuario na tabela
        USERS_TABLE[payload.decode("utf-8")] = id(conexao)


    if cmd == b'PRIVMSG':
        tgt_usr, msg_bytes = payload.split(b' :', 1)
        try:
            tgt_conn_id = USERS_TABLE[tgt_usr.decode("utf-8")]
        except KeyError:
            return

        get_object_by_id(tgt_conn_id).enviar(msg(f':{get_nick_from_conn(conexao)} PRIVMSG {tgt_usr.decode("utf-8")} :{msg_bytes.decode("utf-8")}'))


    if cmd == b'JOIN':
        payload = bytes(payload.decode("utf-8").lower(), 'utf-8')
        if not payload.startswith(b'#'):
            return conexao.enviar(msg(f':server 403 {payload.decode("utf-8")} :No such channel'))

        channel_name = payload.decode("utf-8")
        if channel_name not in CHANNEL_TABLE:
            CHANNEL_TABLE[channel_name] = []

        curr_usr = get_nick_from_conn(conexao)
        CHANNEL_TABLE[channel_name].append(curr_usr)

        for usr in CHANNEL_TABLE[channel_name]:
            get_object_by_id(USERS_TABLE[usr]).enviar(msg(f':{curr_usr} JOIN :{channel_name}'))

        channel_usrs_lst = CHANNEL_TABLE[channel_name]
        channel_usrs_lst.sort()
        full_usr_lst = " ".join(channel_usrs_lst)

        n = 512 - len(f':server 353 {curr_usr} = {channel_name} :') - len(MSG_TERMINATOR)
        chunks = [full_usr_lst[i:i+n] for i in range(0, len(full_usr_lst), n)]
        conexao.enviar(msg(f':server 353 {curr_usr} = {channel_name} :{" ".join(chunks)}'))


    if cmd == b'PART':
        payload = bytes(payload.decode("utf-8").lower(), 'utf-8')
        channel_name = payload.decode("utf-8")
        if not payload.startswith(b'#'):
            return conexao.enviar(msg(f':server 403 {payload.decode("utf-8")} :No such channel'))

        curr_usr = get_nick_from_conn(id(conexao))
        for usr in CHANNEL_TABLE[channel_name]:
            get_object_by_id(USERS_TABLE[usr]).enviar(msg(f':{curr_usr} PART {channel_name}'))

        CHANNEL_TABLE[channel_name].pop(curr_usr)


    print(conexao, dados)


def conexao_aceita(conexao):
    print(conexao, 'nova conexão')
    conexao.registrar_recebedor(dados_recebidos)


servidor = Servidor(6667)
servidor.registrar_monitor_de_conexoes_aceitas(conexao_aceita)
asyncio.get_event_loop().run_forever()
